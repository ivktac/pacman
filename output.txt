from typing import Any

import pygame


class Animation:
    def __init__(
        self, animations_config: dict[str, dict[str, Any]], size: tuple[int, int]
    ) -> None:
        self.animations = {}

        for animation_name, config in animations_config.items():
            image = pygame.image.load(config["image_path"]).convert_alpha()
            frames = self.__split_frames(image, size, config["num_frames"])
            self.animations[animation_name] = frames

        self.__frame_counters = {animation: 0 for animation in animations_config}
        self.current_frames = {animation: 0 for animation in animations_config}

    def get_current_frame(self, animation_name: str) -> pygame.Surface:
        return self.animations[animation_name][self.current_frames[animation_name]]

    def update_frame(self, animation_name: str, frame_delay: int) -> None:
        self.__frame_counters[animation_name] += 1

        if self.__frame_counters[animation_name] > frame_delay:
            self.__frame_counters[animation_name] = 0

            num_frames = len(self.animations[animation_name])

            self.current_frames[animation_name] = (
                self.current_frames[animation_name] + 1
            ) % num_frames

    def __split_frames(
        self, image: pygame.Surface, frame_size: tuple[int, int], num_frames: int
    ) -> list[pygame.Surface]:
        frame_width, frame_height = frame_size

        frames = []
        for i in range(num_frames):
            frame = image.subsurface((i * frame_width, 0, frame_width, frame_height))
            frames.append(frame)

        return frames
import sys
import pygame
from engine.settings import JsonSettings, SettingsManager

from entities.player import Player
from engine.level import Level
from engine.ui.menus import Menu
from engine.ui.ui import UI


class Game:
    def __init__(self) -> None:
        pygame.init()

        pygame.display.set_caption("Pacman")
        self.__settings = SettingsManager(JsonSettings("data/settings.json"))
        self.__settings.load()

        self.__screen = pygame.display.set_mode(
            self.__settings.get_size(), pygame.HWSURFACE | pygame.DOUBLEBUF
        )

        self.__background_image = pygame.image.load(
            "assets/images/background.jpg"
        ).convert()
        self.__background_image = pygame.transform.scale(
            self.__background_image, self.__settings.get_size()
        )

        self.__clock = pygame.time.Clock()

        self.__current_level = 1

        self.__player: Player = Player(-100, -100)

        self.__menu = Menu(
            {"start": self.start, "quit": self.quit, "resume": self.resume},
            self.__settings,
        )
        self.__menu.open_main()

        self.__is_paused = False
        self.__is_running = True

        self.__is_debug = True

        self.__level: Level | None = None
        self.__ui = UI()

    def run(self) -> None:
        while self.__is_running:
            self.handle_events()

            self.update()

            self.clear_screen()

            self.draw()

            pygame.display.flip()

            self.__clock.tick(60)

    def handle_events(self) -> None:
        for event in pygame.event.get():
            match event.type:
                case pygame.QUIT:
                    self.quit()
                case pygame.KEYDOWN:
                    if self.__is_debug:
                        self.debug_handle_keydown(event.key)
                    self.__menu.handle_keydown(event.key)
                    self.__player.handle_keydown(event.key)

    def update(self) -> None:
        if self.__level is None:
            return

        if self.__menu.is_open():
            self.__menu.update()

        if self.__player.dead() and self.__player.time_since_death() > 3500:
            self.__menu.open_new_record(self.__player.score())
            self.__player = Player(-100, -100)
            return

        if self.__level.is_completed():
            self.load_level(self.__current_level + 1)
            return

        self.__level.update()

    def draw(self) -> None:
        if self.__menu.is_open():
            self.__menu.draw(self.__screen)
            return

        self.__level.draw(self.__screen)
        self.__ui.display(
            self.__screen,
            self.__settings.get_font(),
            self.__player.score(),
            self.__current_level,
            self.__player.health(),
        )

    def clear_screen(
        self,
    ) -> None:
        self.__screen.blit(self.__background_image, (0, 0))

    def start(self) -> None:
        self.__menu.close()
        self.__is_paused = False

        self.__player = Player(-100, -100)

        self.__current_level = 1

        self.load_level(self.__current_level)

    def pause(self) -> None:
        self.__is_paused = True
        self.__menu.open_pause()

    def toggle_pause(self) -> None:
        if self.__is_paused:
            self.resume()
        else:
            self.pause()

    def resume(self) -> None:
        self.__is_paused = False
        self.__menu.close()

    def quit(self) -> None:
        pygame.quit()
        sys.exit()

    def load_level(self, level: int) -> None:
        try:
            self.__current_level = level
            self.__level = Level(self.__current_level, self.__player)
        except FileNotFoundError:
            self.__menu.open_game_over()

    def debug_handle_keydown(self, key: int) -> None:
        match key:
            case pygame.K_F1:
                self.start()
            case pygame.K_F2:
                self.load_level(self.__current_level + 1)
            case pygame.K_F3:
                if self.__current_level - 1 < 1:
                    self.load_level(1)
                self.load_level(self.__current_level - 1)
            case pygame.K_F4:
                self.__player.die()
import os
import pygame

from entities.player import Player
from entities.food import Food
from entities.wall import Wall
from entities.ghost import Ghost


class Level(pygame.sprite.Group):
    def __init__(self, number: int, player: Player) -> None:
        super().__init__()

        self.__player = player

        self.__number = number

        self.load()

    @property
    def player(self) -> Player:
        return self.__player

    def load(self) -> None:
        filename = f"assets/levels/{self.__number}.txt"
        if not os.path.exists(filename):
            raise FileNotFoundError(f"Level {self.__number} not found")

        with open(f"assets/levels/{self.__number}.txt", "r") as file:
            data = file.read().splitlines()

        self.empty()

        self.create(data)

    def create(self, data) -> None:
        for y, line in enumerate(data):
            for x, tile in enumerate(line):
                match tile:
                    case "=":
                        self.add(Wall(x, y))
                    case "P":
                        self.__player.respawn(x * 40 + 5, y * 40 + 5)
                    case "*":
                        self.add(Food(x, y, "food"))
                    case "C":
                        self.add(Food(x, y, "cherry"))
                    case "B":
                        self.add(Food(x, y, "blueberry"))
                    case "G":
                        speed = round(self.__number * 0.25 + 2)
                        self.add(Ghost(x, y, speed))

    def draw(self, screen: pygame.Surface) -> None:
        for sprite in self.sprites():
            sprite.draw(screen)

        self.__player.draw(screen)

    def update(self) -> None:
        for sprite in self.sprites():
            sprite.update(self)

        self.__player.update(self)

    def is_completed(self) -> bool:
        return not any(isinstance(entity, Food) for entity in self.sprites())
from typing import Callable
from enum import IntEnum
import pygame

from engine.settings import SettingsManager


class MenuOption:
    def __init__(self, label: str, action: Callable) -> None:
        self.__label = label
        self.__action = action

    def __call__(self) -> None:
        self.__action()

    def __str__(self) -> str:
        return self.__label

    def change_label(self, label: str) -> None:
        self.__label = label


class BaseMenu(pygame.sprite.Sprite):
    def __init__(
        self,
        font: pygame.font.Font,
        colors: dict[str, str],
        title: str = "",
    ) -> None:
        super().__init__()

        self.__selected = 0
        self.__options: list[MenuOption] = []

        self.__font = font
        self.__title_color = colors.get("title", "blue")
        self.__text_color = colors.get("text", "white")
        self.__selected_color = colors.get("selected", "yellow")

        self.__title = title

    def draw(self, screen: pygame.Surface) -> None:
        width, height = screen.get_size()
        option_height = height // (len(self.__options) + 1)

        self.draw_title(screen, width, option_height)
        self.draw_options(screen, width, option_height)

    def add_option(self, option: MenuOption) -> None:
        self.__options.append(option)

    def change_option_label(self, index: int, label: str) -> None:
        self.__options[index].change_label(label)

    def change_font(self, font: pygame.font.Font) -> None:
        self.__font = font

    def change_title(self, title: str) -> None:
        self.__title = title

    def handle_keydown(self, key: int) -> None:
        match key:
            case pygame.K_UP:
                self.next_option(-1)
            case pygame.K_DOWN:
                self.next_option(1)
            case pygame.K_RETURN:
                self.__options[self.__selected]()

    def next_option(self, value: int) -> None:
        self.__selected = (self.__selected + value) % len(self.__options)

    def draw_title(self, screen: pygame.Surface, width: int, height: int) -> None:
        title_surface = self.__font.render(self.__title, True, self.__title_color)

        title_rect = title_surface.get_rect()
        title_rect.center = width // 2, height // 2

        screen.blit(title_surface, title_rect)

    def draw_options(self, screen: pygame.Surface, width: int, height: int) -> None:
        for i, option in enumerate(self.__options):
            color = self.__selected_color if i == self.__selected else self.__text_color

            option_surface = self.__font.render(str(option), True, color)

            option_rect = option_surface.get_rect()
            option_rect.center = width // 2, (i + 1) * height

            screen.blit(option_surface, option_rect)

    def __str__(self) -> str:
        return self.__title


class MenuState(IntEnum):
    MAIN = 0
    SETTINGS = 1
    PAUSE = 2
    NEW_RECORD = 3
    GAME_OVER = 4


class MenuGroup(pygame.sprite.Group):
    def __init__(self, *sprites: BaseMenu) -> None:
        super().__init__(*sprites)

        self.__stack = []
        self.__current: int | None = None

    def handle_keydown(self, key: int) -> None:
        if self.__current is not None:
            self.sprites()[self.__current].handle_keydown(key)

    def add_option(self, index: int, option: MenuOption) -> None:
        self.sprites()[index].add_option(option)

    def open_menu(self, index: int) -> None:
        self.__stack.append(self.__current)
        self.__current = index

    def close_menu(self) -> None:
        self.__current = self.__stack.pop() if self.__stack else None

    def draw(self, screen: pygame.Surface) -> None:
        if self.__current is not None:
            self.sprites()[self.__current].draw(screen)

    def __getitem__(self, index: int) -> BaseMenu:
        return self.sprites()[index]

    def update(self) -> None:
        ...

    def __bool__(self) -> bool:
        return self.__current is not None

    def __add__(self, other: BaseMenu):
        self.add(other)
        return self


class Menu:
    def __init__(
        self,
        callbacks: dict[str, Callable],
        settings_manager: SettingsManager,
    ) -> None:
        self.__colors = {"title": "blue", "text": "black", "selected": "yellow"}
        self.__callbacks = callbacks
        self.__settings_manager = settings_manager

        self.__font_size = self.__settings_manager.get_font_size()
        self.__font = self.__settings_manager.get_font()

        self.__menus = MenuGroup(BaseMenu(self.__font, self.__colors, "Головне меню"))

        self.__menus += BaseMenu(self.__font, self.__colors, "Налаштування")
        self.__menus += BaseMenu(self.__font, self.__colors, "Пауза")
        self.__menus += BaseMenu(self.__font, self.__colors, "Новий рекорд")
        self.__menus += BaseMenu(self.__font, self.__colors, "Кінець гри")

        self.__add_options_to_menus(self.__menus)

    def get_font(self) -> pygame.font.Font:
        return self.__font

    def update(self) -> None:
        self.__menus.update()

    def draw(self, screen: pygame.Surface) -> None:
        self.__menus.draw(screen)

    def open_settings(self) -> None:
        self.__menus.open_menu(MenuState.SETTINGS)

    def open_previous(self) -> None:
        self.__menus.close_menu()

    def open_pause(self) -> None:
        self.__menus.open_menu(MenuState.PAUSE)

    def open_game_over(self) -> None:
        self.__menus.open_menu(MenuState.GAME_OVER)

    def open_new_record(self, score: int) -> None:
        new_title = f"Ваш результат: {score}"

        if score > self.__settings_manager.get_highscore():
            new_title = f"Новий рекорд: {score}!!!"
            self.__settings_manager.set("highscore", score)
            self.__settings_manager.save()

        self.__menus[MenuState.NEW_RECORD].change_title(new_title)
        self.__menus.open_menu(MenuState.NEW_RECORD)

    def open_main(self) -> None:
        self.__menus[MenuState.MAIN].change_title(
            f"Рекорд: {self.__settings_manager.get_highscore()}"
        )
        self.__menus.open_menu(MenuState.MAIN)

    def close(self) -> None:
        self.__menus.close_menu()

    def is_open(self) -> bool:
        return bool(self.__menus)

    def handle_keydown(self, key: int) -> None:
        if key == pygame.K_ESCAPE and not self.is_open():
            self.open_pause()

        self.__menus.handle_keydown(key)

    def __add_options_to_menus(self, menus: MenuGroup) -> None:
        menus.add_option(MenuState.PAUSE, MenuOption("Продовжити", self.__resume_game))

        self.__add_default_options(menus[MenuState.MAIN])
        self.__add_default_options(menus[MenuState.PAUSE])
        self.__add_default_options(menus[MenuState.GAME_OVER])
        self.__add_default_options(menus[MenuState.NEW_RECORD])

        self.__add_settings_options(menus[MenuState.SETTINGS])

    def __add_default_options(self, menu: BaseMenu) -> None:
        menu.add_option(MenuOption("Нова гра", self.__start_game))
        menu.add_option(MenuOption("Налаштування", self.open_settings))
        menu.add_option(MenuOption("Вийти", self.__quit_game))

    def __add_settings_options(self, menu: BaseMenu) -> None:
        menu.add_option(MenuOption("Змінити розмір шрифт", self.__change_font_size))
        menu.add_option(MenuOption("Зберегти", self.__save_settings))
        menu.add_option(MenuOption("Назад", self.open_previous))

    def __start_game(self) -> None:
        self.__callbacks["start"]()

    def __quit_game(self) -> None:
        self.__callbacks["quit"]()

    def __resume_game(self) -> None:
        self.__callbacks["resume"]()

    def __change_font_size(self) -> None:
        names = self.__settings_manager.get_font_size_names()
        self.__font_size = names[(names.index(self.__font_size) + 1) % len(names)]

        self.__menus[MenuState.SETTINGS].change_option_label(
            0, f"Змінити розмір шрифт: {self.__font_size}"
        )

    def __change_font(self) -> None:
        self.__font = self.__settings_manager.get_font()

        for menu in self.__menus.sprites():
            if type(menu) is not BaseMenu:
                continue
            menu.change_font(self.__font)

    def __save_settings(self) -> None:
        self.__settings_manager.set("font", self.__font_size)
        self.__settings_manager.save()

        self.__change_font()

        self.open_previous()
import pygame


class UI:
    def __init__(self) -> None:
        self.__heart_image = pygame.image.load("assets/images/heart.png")
        self.__heart_image = pygame.transform.scale(self.__heart_image, (64, 64))

    def display(
        self,
        screen: pygame.Surface,
        font: pygame.font.Font,
        score: int,
        level: int,
        health: int,
    ) -> None:
        self.__display_score(screen, font, score)
        self.__display_level(screen, font, level)
        self.__display_health(screen, health)

    def __display_score(
        self, screen: pygame.Surface, font: pygame.font.Font, score: int
    ) -> None:
        score_text = font.render(f"Score: {score}", True, "white")
        screen.blit(score_text, [0, 30])

    def __display_level(
        self, screen: pygame.Surface, font: pygame.font.Font, level: int
    ) -> None:
        level_text = font.render(f"Level: {level}", True, "white")
        screen.blit(level_text, [0, 60])

    def __display_health(self, screen: pygame.Surface, health: int) -> None:
        for i in range(health):
            screen.blit(self.__heart_image, [i * 32, -10])
import os
import json
from abc import ABC, abstractmethod
from typing import Any

import pygame


class AbstractSettings(ABC):
    @abstractmethod
    def get(self, key: str, default: Any) -> None:
        ...

    @abstractmethod
    def set(self, key: str, value: Any) -> None:
        ...

    @abstractmethod
    def save(self):
        ...

    @abstractmethod
    def load(self) -> None:
        ...


class JsonSettings(AbstractSettings):
    def __init__(self, path: str) -> None:
        self.__path = path
        self.__data = {}

    def get(self, key: str, default: Any) -> Any:
        return self.__data.get(key, default)

    def set(self, key: str, value: Any) -> None:
        self.__data[key] = value

    def save(self) -> None:
        with open(self.__path, "w") as file:
            json.dump(self.__data, file, indent=4)

    def load(self) -> None:
        if os.path.exists(self.__path):
            with open(self.__path, "r") as file:
                self.__data = json.load(file)


class FontManager:
    def __init__(self) -> None:
        self.__size_names = ["small", "default", "large", "huge"]
        self.__fonts: dict[str, pygame.font.Font] = {}

        self.__init_fonts()

    def __init_fonts(self) -> None:
        for size_name, size in zip(self.__size_names, [32, 48, 64, 80]):
            self.__fonts[size_name] = pygame.font.Font(None, size)

    def get(self, name: str) -> pygame.font.Font:
        return self.__fonts[name]

    def get_size_names(self) -> list[str]:
        return self.__size_names


class SettingsManager:
    def __init__(self, settings: AbstractSettings) -> None:
        self.__settings = settings
        self.__font_manager = FontManager()

    def get_size(self) -> tuple[int, int]:
        return self.__settings.get("width", 800), self.__settings.get("height", 800)

    def get_fps(self) -> int:
        return self.__settings.get("fps", 60)

    def get_font(self) -> pygame.font.Font:
        return self.__font_manager.get(self.__settings.get("font", "default"))

    def get_font_size(self) -> str:
        return self.__settings.get("font_size", "default")

    def get_font_size_names(self) -> list[str]:
        return self.__font_manager.get_size_names()

    def get_highscore(self) -> int:
        return self.__settings.get("highscore", 0)

    def set(self, key: str, value: Any) -> None:
        self.__settings.set(key, value)

    def save(self) -> None:
        self.__settings.save()

    def load(self) -> None:
        self.__settings.load()
import pygame


class Entity(pygame.sprite.Sprite):
    image: pygame.Surface
    rect: pygame.Rect

    def __init__(self, x: int, y: int, size: int, tag: str, *groups) -> None:
        super().__init__(*groups)

        self.__x = x
        self.__y = y
        self.__size = size
        self.__tag = tag

    @property
    def size(self) -> int:
        return self.__size

    @classmethod
    def from_image(cls, x: int, y: int, size: int, image_path: str, tag: str, *groups):
        entity = cls(x, y, size, tag, *groups)

        entity.image = pygame.image.load(image_path).convert_alpha()
        entity.image = pygame.transform.scale(
            entity.image, (entity.__size, entity.__size)
        )
        entity.rect = entity.image.get_rect(topleft=[entity.__x, entity.__y])

        return entity

    @classmethod
    def from_color(cls, x: int, y: int, size: int, color: str, tag: str, *groups):
        entity = cls(x, y, size, tag, *groups)
        entity.image = pygame.Surface(
            [entity.__size, entity.__size], pygame.SRCALPHA, 32
        ).convert_alpha()

        pygame.draw.circle(
            entity.image,
            color,
            (entity.__size // 2, entity.__size // 2),
            entity.__size // 2,
        )
        entity.rect = entity.image.get_rect(topleft=[entity.__x, entity.__y])

        return entity

    def draw(self, screen: pygame.Surface) -> None:
        screen.blit(self.image, self.rect)

    def __str__(self) -> str:
        return self.__tag

    def update(self, _: pygame.sprite.Group) -> None:
        ...


class MovableEntity(Entity):
    def __init__(
        self, x: int, y: int, size: int, speed: int, image_path: str, tag: str, *groups
    ) -> None:
        entity = Entity.from_image(x, y, size, image_path, tag, *groups)
        self.__dict__.update(entity.__dict__)

        self.__speed = speed
        self.__direction = pygame.math.Vector2(0, 0)

    @property
    def direction(self) -> pygame.math.Vector2:
        return self.__direction
    
    @property
    def speed(self) -> int:
        return self.__speed

    def update(self, group: pygame.sprite.Group) -> None:
        self.move(group)

    def move(self, group: pygame.sprite.Group) -> None:
        new_position = self.rect.move(self.__direction * self.__speed)

        if not self.check_collision(new_position, group):
            self.rect = new_position

        self.wrap_around()

    def check_collision(self, rect: pygame.Rect, group: pygame.sprite.Group) -> bool:
        for entity in group.sprites():
            if str(entity) == "wall":
                if rect.colliderect(entity.rect):
                    return True

        return False

    def wrap_around(self) -> None:
        gap = 10
        screen_width, screen_height = pygame.display.get_surface().get_size()

        if self.rect.left > screen_width - gap:
            self.rect.right = gap
        elif self.rect.right < gap:
            self.rect.left = screen_width - gap

        if self.rect.top > screen_height - gap:
            self.rect.bottom = gap
        elif self.rect.bottom < gap:
            self.rect.top = screen_height - gap

    def change_direction(self, x: int, y: int):
        self.__direction = pygame.math.Vector2(x, y)
import pygame
from engine.animation import Animation

from entities.entity import MovableEntity, Entity


class Player(MovableEntity):
    def __init__(self, x: int, y: int, *groups) -> None:
        super().__init__(x, y, 32, 3, "assets/images/pacman.png", "player", *groups)

        self.__image_idle = self.image

        self.__animation = Animation(
            {
                "walk": {"image_path": "assets/images/walk.png", "num_frames": 3},
                "explosion": {
                    "image_path": "assets/images/explosion.png",
                    "num_frames": 10,
                },
            },
            (self.size, self.size),
        )

        self.rect = self.image.get_rect()

        self.__score = 0

        self.__is_dead = False
        self.__death_time = 0

        self.__max_health = 3
        self.__health = self.__max_health

        self.__immunity_duration = 3000
        self.__immunity_end_time = 0

        self.__immunity = False

        self.__blink_duration = 200
        self.__blink_end_time = 0
        self.__visible = True

    def score(self) -> int:
        return self.__score

    def health(self) -> int:
        return self.__health

    def dead(self) -> bool:
        return self.__is_dead

    def time_since_death(self) -> int:
        return pygame.time.get_ticks() - self.__death_time

    def draw(self, screen: pygame.Surface) -> None:
        if self.__visible:
            screen.blit(self.image, self.rect.topleft)

    def update(self, group: pygame.sprite.Group) -> None:
        if self.__is_dead:
            return self.animate_explosion()

        if self.__health <= 0:
            return self.die()

        self.move(group)
        self.animate()

    def animate(self) -> None:
        if self.direction.magnitude() == 0:
            self.image = self.__image_idle
        else:
            self.update_pacman_frame()

        self.image = self.rotate()

        self.blink()

    def update_pacman_frame(self):
        self.__animation.update_frame("walk", 10)
        self.image = self.__animation.get_current_frame("walk")

    def rotate(self) -> pygame.Surface:
        angle = self.direction.angle_to(pygame.math.Vector2(1, 0))
        return pygame.transform.rotate(self.image, angle)

    def blink(self) -> None:
        self.check_immunity()

        if self.__immunity:
            if pygame.time.get_ticks() > self.__blink_end_time:
                self.__visible = not self.__visible
                self.__blink_end_time = pygame.time.get_ticks() + self.__blink_duration
        else:
            self.__visible = True

    def animate_explosion(self) -> None:
        current_time = pygame.time.get_ticks()

        elapsed_time = current_time - self.__death_time
        frame_delay = 3000 // len(self.__animation.animations["explosion"])

        self.__animation.current_frames["explosion"] = elapsed_time // frame_delay

        self.__animation.current_frames["explosion"] = min(
            self.__animation.current_frames["explosion"],
            len(self.__animation.animations["explosion"]) - 1,
        )

        self.image = self.__animation.get_current_frame("explosion")

        self.kill()

    def die(self) -> None:
        self.__is_dead = True
        self.__exploding = True
        self.__death_time = pygame.time.get_ticks()

        self.change_direction(0, 0)

    def eat_food(self, food: Entity) -> None:
        match str(food):
            case "cherry":
                self.increase_health()
            case "blueberry":
                self.give_immunity()
            case _:
                ...

        self.__score += food.points

    def respawn(self, x: int, y: int) -> None:
        dump_score = self.__score

        self.__init__(x, y)

        self.__score = dump_score

        self.rect.topleft = (x, y)

    def increase_health(self) -> None:
        self.__health = min(self.__health + 1, self.__max_health)

    def give_immunity(self) -> None:
        self.__immunity = True
        self.__immunity_end_time = pygame.time.get_ticks() + self.__immunity_duration

    def take_damage(self) -> None:
        if not self.__immunity:
            self.__health -= 1
            self.give_immunity()

    def check_collision(self, rect: pygame.Rect, group: pygame.sprite.Group) -> bool:
        for entity in group.sprites():
            if self.rect.colliderect(entity.rect):
                match str(entity):
                    case "ghost":
                        self.take_damage()
                    case "food" | "cherry" | "blueberry":
                        self.eat_food(entity)
                        entity.kill()

        return super().check_collision(rect, group)

    def check_immunity(self) -> None:
        if self.__immunity and pygame.time.get_ticks() > self.__immunity_end_time:
            self.__immunity = False

    def handle_keydown(self, key: int) -> None:
        match key:
            case pygame.K_UP | pygame.K_w:
                self.change_direction(0, -1)
            case pygame.K_DOWN | pygame.K_s:
                self.change_direction(0, 1)
            case pygame.K_LEFT | pygame.K_a:
                self.change_direction(-1, 0)
            case pygame.K_RIGHT | pygame.K_d:
                self.change_direction(1, 0)
from entities.entity import Entity


class Wall(Entity):
    def __init__(self, x: int, y: int, *groups) -> None:
        entity = Entity.from_image(
            x * 40, y * 40, 40, "assets/images/wall.png", "wall", *groups
        )

        self.__dict__.update(entity.__dict__)
import random
from entities.entity import Entity


class Food(Entity):
    def __init__(self, x: int, y: int, tag: str = "food", *groups) -> None:
        self.points = random.randint(1, 10)

        image_path = None

        match tag:
            case "cherry":
                image_path = "assets/images/cherry.png"
                tag = "cherry"
                self.points = 100
            case "blueberry":
                image_path = "assets/images/blueberry.png"
                tag = "blueberry"
                self.points = 300
            case _:
                tag = "food"

        if image_path is not None:
            entity = Entity.from_image(x * 40, y * 40, 32, image_path, tag, *groups)
        else:
            entity = Entity.from_color(
                x * 40 + 16, y * 40 + 16, 16, "yellow", tag, *groups
            )

        self.__dict__.update(entity.__dict__)
import random

import pygame


from entities.entity import Entity, MovableEntity


class Ghost(MovableEntity):
    def __init__(
        self,
        x: int,
        y: int,
        speed: int,
        *groups,
    ) -> None:
        super().__init__(
            x * 40, y * 40, 32, speed, "assets/images/ghost.png", "ghost", *groups
        )

    def move(self, group: pygame.sprite.Group) -> None:
        if random.random() < 0.01:
            dx, dy = random.choice([(1, 0), (-1, 0), (0, 1), (0, -1)])
            self.change_direction(dx, dy)

        if not hasattr(group, "player"):
            return

        player = group.player

        if not isinstance(player, Entity):
            return

        if self.is_player_is_sight(player):
            dx, dy = player.rect.x - self.rect.x, player.rect.y - self.rect.y

            if abs(dx) > abs(dy):
                self.change_direction(1 if dx > 0 else -1, 0)
            else:
                self.change_direction(0, 1 if dy > 0 else -1)

        super().move(group)

    def is_player_is_sight(self, entity: Entity) -> None:
        sight_distance = 100 * self.speed
        sight_rect = self.rect.inflate(sight_distance, sight_distance)

        if self.direction.x > 0:
            sight_rect.x += self.rect.width
        elif self.direction.x < 0:
            sight_rect.x -= sight_distance

        if self.direction.y > 0:
            sight_rect.y += self.rect.height
        elif self.direction.y < 0:
            sight_rect.y -= sight_distance

        return sight_rect.colliderect(entity.rect)
from engine.game import Game


def main() -> None:
    game = Game()
    game.run()


if __name__ == "__main__":
    main()

import pygame


class Entity(pygame.sprite.Sprite):
    image: pygame.Surface
    rect: pygame.Rect

    def __init__(self, x: int, y: int, size: int, tag: str, *groups) -> None:
        super().__init__(*groups)

        self.__x = x
        self.__y = y
        self.__size = size
        self.__tag = tag

    @property
    def size(self) -> int:
        return self.__size

    @classmethod
    def from_image(cls, x: int, y: int, size: int, image_path: str, tag: str, *groups):
        entity = cls(x, y, size, tag, *groups)

        entity.image = pygame.image.load(image_path).convert_alpha()
        entity.image = pygame.transform.scale(
            entity.image, (entity.__size, entity.__size)
        )
        entity.rect = entity.image.get_rect(topleft=[entity.__x, entity.__y])

        return entity

    @classmethod
    def from_color(cls, x: int, y: int, size: int, color: str, tag: str, *groups):
        entity = cls(x, y, size, tag, *groups)
        entity.image = pygame.Surface(
            [entity.__size, entity.__size], pygame.SRCALPHA, 32
        ).convert_alpha()

        pygame.draw.circle(
            entity.image,
            color,
            (entity.__size // 2, entity.__size // 2),
            entity.__size // 2,
        )
        entity.rect = entity.image.get_rect(topleft=[entity.__x, entity.__y])

        return entity

    def draw(self, screen: pygame.Surface) -> None:
        screen.blit(self.image, self.rect)

    def __str__(self) -> str:
        return self.__tag

    def update(self, _: pygame.sprite.Group) -> None:
        ...


class MovableEntity(Entity):
    def __init__(
        self, x: int, y: int, size: int, speed: int, image_path: str, tag: str, *groups
    ) -> None:
        entity = Entity.from_image(x, y, size, image_path, tag, *groups)
        self.__dict__.update(entity.__dict__)

        self.__speed = speed
        self.__direction = pygame.math.Vector2(0, 0)

    @property
    def direction(self) -> pygame.math.Vector2:
        return self.__direction

    def update(self, group: pygame.sprite.Group) -> None:
        self.move(group)

    def move(self, group: pygame.sprite.Group) -> None:
        new_position = self.rect.move(self.__direction * self.__speed)

        if not self.check_collision(new_position, group):
            self.rect = new_position

        self.wrap_around()

    def check_collision(self, rect: pygame.Rect, group: pygame.sprite.Group) -> bool:
        for entity in group.sprites():
            if str(entity) == "wall":
                if rect.colliderect(entity.rect):
                    return True

        return False

    def wrap_around(self) -> None:
        gap = 10
        screen_width, screen_height = pygame.display.get_surface().get_size()

        if self.rect.left > screen_width - gap:
            self.rect.right = gap
        elif self.rect.right < gap:
            self.rect.left = screen_width - gap

        if self.rect.top > screen_height - gap:
            self.rect.bottom = gap
        elif self.rect.bottom < gap:
            self.rect.top = screen_height - gap

    def change_direction(self, x: int, y: int):
        self.__direction = pygame.math.Vector2(x, y)
import random
from entities.entity import Entity


class Food(Entity):
    def __init__(self, x: int, y: int, tag: str = "food", *groups) -> None:
        self.points = random.randint(1, 10)

        image_path = None

        match tag:
            case "cherry":
                image_path = "assets/images/cherry.png"
                tag = "cherry"
                self.points = 100
            case "blueberry":
                image_path = "assets/images/blueberry.png"
                tag = "blueberry"
                self.points = 300
            case _:
                tag = "food"

        if image_path is not None:
            entity = Entity.from_image(x * 40, y * 40, 32, image_path, tag, *groups)
        else:
            entity = Entity.from_color(
                x * 40 + 16, y * 40 + 16, 16, "yellow", tag, *groups
            )

        self.__dict__.update(entity.__dict__)
import random

import pygame


from entities.entity import Entity, MovableEntity


class Ghost(MovableEntity):
    def __init__(
        self,
        x: int,
        y: int,
        speed: int,
        *groups,
    ) -> None:
        super().__init__(
            x * 40, y * 40, 32, speed, "assets/images/ghost.png", "ghost", *groups
        )

    def move(self, group: pygame.sprite.Group) -> None:
        if random.random() < 0.01:
            dx, dy = random.choice([(1, 0), (-1, 0), (0, 1), (0, -1)])
            self.change_direction(dx, dy)

        if not hasattr(group, "player"):
            return

        player = group.player

        if self.is_player_is_sight(player):
            dx, dy = player.rect.x - self.rect.x, player.rect.y - self.rect.y

            if abs(dx) > abs(dy):
                self.change_direction(1 if dx > 0 else -1, 0)
            else:
                self.change_direction(0, 1 if dy > 0 else -1)

        super().move(group)

    def is_player_is_sight(self, entity: Entity) -> None:
        sight_distance = 200
        sight_rect = self.rect.inflate(sight_distance, sight_distance)

        if self.direction.x > 0:
            sight_rect.x += self.rect.width
        elif self.direction.x < 0:
            sight_rect.x -= sight_distance

        if self.direction.y > 0:
            sight_rect.y += self.rect.height
        elif self.direction.y < 0:
            sight_rect.y -= sight_distance

        return sight_rect.colliderect(entity.rect)
import pygame

from entities.entity import MovableEntity, Entity


class Player(MovableEntity):
    def __init__(self, x: int, y: int, *groups) -> None:
        super().__init__(x, y, 32, 3, "assets/images/pacman.png", "player", *groups)

        self.__image_idle = self.image

        walk_image = pygame.image.load("assets/images/walk.png").convert_alpha()
        self.__walk_frames = self.split_frames(walk_image, (self.size, self.size), 3)

        explosion_image = pygame.image.load(
            "assets/images/explosion.png"
        ).convert_alpha()
        self.__explosion_frames = self.split_frames(
            explosion_image, (self.size - 2, self.size), 10
        )

        self.image = self.__image_idle
        self.rect = self.image.get_rect()

        self.__score = 0

        self.__frame_counter = 0
        self.__current_frame = 0

        self.__exploding = False
        self.__explosion_frame_delay = 3000 // len(self.__explosion_frames)

        self.__is_dead = False
        self.__death_time = 0

        self.__max_health = 3
        self.__health = self.__max_health

        self.__immunity_duration = 3000
        self.__immunity_end_time = 0

        self.__immunity = False

        self.__blink_duration = 200
        self.__blink_end_time = 0
        self.__visible = True

    @staticmethod
    def split_frames(
        image: pygame.Surface, frame_size: tuple[int, int], num_frames: int
    ) -> list[pygame.Surface]:
        frame_width, frame_height = frame_size

        frames = []
        for i in range(num_frames):
            frame = image.subsurface((i * frame_width, 0, frame_width, frame_height))
            frames.append(frame)

        return frames

    def score(self) -> int:
        return self.__score

    def health(self) -> int:
        return self.__health

    def dead(self) -> bool:
        return self.__is_dead

    def time_since_death(self) -> int:
        return pygame.time.get_ticks() - self.__death_time

    def draw(self, screen: pygame.Surface) -> None:
        if self.__visible or self.__exploding:
            screen.blit(self.image, self.rect.topleft)

    def update(self, group: pygame.sprite.Group) -> None:
        if self.__is_dead:
            return self.animate_explosion()

        if self.__health <= 0:
            return self.die()

        self.move(group)
        self.animate()

    def animate(self) -> None:
        if self.direction.magnitude() == 0:
            self.image = self.__image_idle
        else:
            self.update_pacman_frame()

        self.image = self.rotate()

        self.blink()

    def update_pacman_frame(self):
        self.__frame_counter += 1
        if self.__frame_counter > 10:
            self.__frame_counter = 0
            self.__current_frame = (self.__current_frame + 1) % len(self.__walk_frames)
        self.image = self.__walk_frames[self.__current_frame]

    def rotate(self) -> pygame.Surface:
        angle = self.direction.angle_to(pygame.math.Vector2(1, 0))
        return pygame.transform.rotate(self.image, angle)

    def blink(self) -> None:
        self.check_immunity()

        if self.__immunity:
            if pygame.time.get_ticks() > self.__blink_end_time:
                self.__visible = not self.__visible
                self.__blink_end_time = pygame.time.get_ticks() + self.__blink_duration
        else:
            self.__visible = True

    def animate_explosion(self) -> None:
        current_time = pygame.time.get_ticks()

        elapsed_time = current_time - self.__death_time

        self.__current_frame = elapsed_time // self.__explosion_frame_delay
        self.__current_frame = min(
            self.__current_frame, len(self.__explosion_frames) - 1
        )

        self.image = self.__explosion_frames[self.__current_frame]

        if self.__current_frame == len(self.__explosion_frames) - 1:
            self.kill()

    def die(self) -> None:
        self.__is_dead = True
        self.__exploding = True
        self.__death_time = pygame.time.get_ticks()

        self.change_direction(0, 0)

    def eat_food(self, food: Entity) -> None:
        match str(food):
            case "cherry":
                self.increase_health()
            case "blueberry":
                self.give_immunity()
            case _:
                ...

        self.__score += food.points

    def respawn(self, x: int, y: int) -> None:
        dump_score = self.__score

        self.__init__(x, y)

        self.__score = dump_score

        self.rect.topleft = (x, y)

    def increase_health(self) -> None:
        self.__health = min(self.__health + 1, self.__max_health)

    def give_immunity(self) -> None:
        self.__immunity = True
        self.__immunity_end_time = pygame.time.get_ticks() + self.__immunity_duration

    def take_damage(self) -> None:
        if not self.__immunity:
            self.__health -= 1
            self.give_immunity()

    def check_collision(self, rect: pygame.Rect, group: pygame.sprite.Group) -> bool:
        for entity in group.sprites():
            if self.rect.colliderect(entity.rect):
                match str(entity):
                    case "ghost":
                        self.take_damage()
                    case "food" | "cherry" | "blueberry":
                        self.eat_food(entity)
                        entity.kill()

        return super().check_collision(rect, group)

    def check_immunity(self) -> None:
        if self.__immunity and pygame.time.get_ticks() > self.__immunity_end_time:
            self.__immunity = False

    def handle_keydown(self, key: int) -> None:
        match key:
            case pygame.K_UP | pygame.K_w:
                self.change_direction(0, -1)
            case pygame.K_DOWN | pygame.K_s:
                self.change_direction(0, 1)
            case pygame.K_LEFT | pygame.K_a:
                self.change_direction(-1, 0)
            case pygame.K_RIGHT | pygame.K_d:
                self.change_direction(1, 0)
from entities.entity import Entity


class Wall(Entity):
    def __init__(self, x: int, y: int, *groups) -> None:
        entity = Entity.from_image(
            x * 40, y * 40, 40, "assets/images/wall.png", "wall", *groups
        )

        self.__dict__.update(entity.__dict__)
from enum import IntEnum
import pygame


class MenuOption:
    def __init__(self, text: str, action: callable) -> None:
        self.__text = text
        self.__action = action

    def __call__(self) -> None:
        self.__action()

    def __str__(self) -> str:
        return self.__text


class BaseMenu(pygame.sprite.Sprite):
    def __init__(
        self,
        font: pygame.font.Font,
        colors: dict[str, str],
        title: str = "",
    ) -> None:
        super().__init__()

        self.__selected = 0
        self.__options: list[MenuOption] = []

        self.__font = font
        self.__title_color = colors.get("title", "blue")
        self.__text_color = colors.get("text", "white")
        self.__selected_color = colors.get("selected", "yellow")

        self.__title = title

    def draw(self, screen: pygame.Surface) -> None:
        width, height = screen.get_size()
        option_height = height // (len(self.__options) + 1)

        self.draw_title(screen, width, option_height)
        self.draw_options(screen, width, option_height)

    def add_option(self, option: MenuOption) -> None:
        self.__options.append(option)

    def change_option(self, index: int, option: MenuOption) -> None:
        self.__options[index] = option

    def change_font(self, font: pygame.font.Font) -> None:
        self.__font = font

    def change_title(self, title: str) -> None:
        self.__title = title

    def handle_keydown(self, key: int) -> None:
        match key:
            case pygame.K_UP:
                self.next_option(-1)
            case pygame.K_DOWN:
                self.next_option(1)
            case pygame.K_RETURN:
                self.__options[self.__selected]()

    def next_option(self, value: int) -> None:
        self.__selected = (self.__selected + value) % len(self.__options)

    def draw_title(self, screen: pygame.Surface, width: int, height: int) -> None:
        title_surface = self.__font.render(self.__title, True, self.__title_color)

        title_rect = title_surface.get_rect()
        title_rect.center = width // 2, height // 2

        screen.blit(title_surface, title_rect)

    def draw_options(self, screen: pygame.Surface, width: int, height: int) -> None:
        for i, option in enumerate(self.__options):
            color = self.__selected_color if i == self.__selected else self.__text_color

            option_surface = self.__font.render(str(option), True, color)

            option_rect = option_surface.get_rect()
            option_rect.center = width // 2, (i + 1) * height

            screen.blit(option_surface, option_rect)

    def __str__(self) -> str:
        return self.__title


class MenuState(IntEnum):
    MAIN = 0
    SETTINGS = 1
    PAUSE = 2
    NEW_RECORD = 3
    GAME_OVER = 4


class MenuGroup(pygame.sprite.Group):
    def __init__(self, *sprites: BaseMenu) -> None:
        super().__init__(*sprites)

        self.__stack = []
        self.__current: int | None = None

    def handle_keydown(self, key: int) -> None:
        if self.__current is not None:
            self.sprites()[self.__current].handle_keydown(key)

    def add_option(self, index: int, option: MenuOption) -> None:
        self.sprites()[index].add_option(option)

    def open_menu(self, index: int) -> None:
        self.__stack.append(self.__current)
        self.__current = index

    def close_menu(self) -> None:
        self.__current = self.__stack.pop() if self.__stack else None

    def draw(self, screen: pygame.Surface) -> None:
        if self.__current is not None:
            self.sprites()[self.__current].draw(screen)

    def update(self) -> None:
        ...

    def __bool__(self) -> bool:
        return self.__current is not None


class MenuInterface:
    def __init__(self, callbacks: dict[str, callable]) -> None:
        self.__callbacks = callbacks

        self.__current_font_size = 20
        self.__font_size = 20

        self.__font_sizes = {
            20: "Малий",
            30: "Середній",
            40: "Великий",
        }

        self.__font = pygame.font.SysFont("monospace", self.__font_size)
        self.__colors = {"title": "blue", "text": "white", "selected": "yellow"}

        self.__menus = MenuGroup(
            BaseMenu(self.__font, self.__colors, "Головне меню"),
            BaseMenu(self.__font, self.__colors, "Налаштування"),
            BaseMenu(self.__font, self.__colors, "Пауза"),
            BaseMenu(self.__font, self.__colors, "Результат"),
            BaseMenu(self.__font, self.__colors, "Кінець гри"),
        )

        self.__menus.add_option(
            MenuState.PAUSE, MenuOption("Продовжити", self.__resume_game)
        )

        for state in [
            MenuState.MAIN,
            MenuState.PAUSE,
            MenuState.NEW_RECORD,
            MenuState.GAME_OVER,
        ]:
            self.__menus.add_option(state, MenuOption("Нова гра", self.__start_game))
            self.__menus.add_option(
                state, MenuOption("Налаштування", self.open_settings)
            )
            self.__menus.add_option(state, MenuOption("Вийти", self.__quit_game))

        self.__menus.add_option(
            MenuState.SETTINGS,
            MenuOption(
                f"Змінити розмір шрифту: {self.__font_sizes[self.__font_size]}",
                self.__change_font_size,
            ),
        )
        self.__menus.add_option(
            MenuState.SETTINGS, MenuOption("Зберегти", self.__save_settings)
        )
        self.__menus.add_option(
            MenuState.SETTINGS, MenuOption("Повернутися", self.open_previous)
        )

    def get_current_font_size(self) -> int:
        return self.__current_font_size

    def update(self) -> None:
        self.__menus.update()

    def draw(self, screen: pygame.Surface) -> None:
        self.__menus.draw(screen)

    def open_settings(self) -> None:
        self.__menus.open_menu(MenuState.SETTINGS)

    def open_previous(self) -> None:
        self.__menus.close_menu()

    def open_pause(self) -> None:
        self.__menus.open_menu(MenuState.PAUSE)

    def open_game_over(self) -> None:
        self.__menus.open_menu(MenuState.GAME_OVER)

    def open_new_record(self, score: int) -> None:
        new_title = f"Ваш результат: {score}"

        self.__menus.sprites()[MenuState.NEW_RECORD].change_title(new_title)
        self.__menus.open_menu(MenuState.NEW_RECORD)

    def open_main(self) -> None:
        self.__menus.open_menu(MenuState.MAIN)

    def close(self) -> None:
        self.__menus.close_menu()

    def is_open(self) -> bool:
        return bool(self.__menus)

    def handle_keydown(self, key: int) -> None:
        if key == pygame.K_ESCAPE and not self.is_open():
            self.open_pause()

        self.__menus.handle_keydown(key)

    def __start_game(self) -> None:
        self.__callbacks["start"]()

    def __quit_game(self) -> None:
        self.__callbacks["quit"]()

    def __resume_game(self) -> None:
        self.__callbacks["resume"]()

    def __change_font_size(self) -> None:
        self.__current_font_size = (
            20 if self.__current_font_size == 40 else self.__current_font_size + 10
        )

        self.__menus.sprites()[MenuState.SETTINGS].change_option(
            0,
            MenuOption(
                f"Змінити розмір шрифту: {self.__font_sizes[self.__current_font_size]}",
                self.__change_font_size,
            ),
        )

    def __save_settings(self) -> None:
        self.__font_size = self.__current_font_size
        self.__font = pygame.font.SysFont("monospace", self.__font_size)

        for menu in self.__menus.sprites():
            menu.change_font(self.__font)

        self.open_previous()
import pygame


class UI:
    def __init__(self) -> None:
        self.__heart_image = pygame.image.load("assets/images/heart.png")
        self.__heart_image = pygame.transform.scale(self.__heart_image, (64, 64))

    def display(
        self,
        screen: pygame.Surface,
        font: pygame.font.Font,
        score: int,
        level: int,
        health: int,
    ) -> None:
        self.__display_score(screen, font, score)
        self.__display_level(screen, font, level)
        self.__display_health(screen, health)

    def __display_score(
        self, screen: pygame.Surface, font: pygame.font.Font, score: int
    ) -> None:
        score_text = font.render(f"Score: {score}", True, "white")
        screen.blit(score_text, [0, 30])

    def __display_level(
        self, screen: pygame.Surface, font: pygame.font.Font, level: int
    ) -> None:
        level_text = font.render(f"Level: {level}", True, "white")
        screen.blit(level_text, [0, 60])

    def __display_health(self, screen: pygame.Surface, health: int) -> None:
        for i in range(health):
            screen.blit(self.__heart_image, [i * 32, -10])
import sys
import pygame

from entities.player import Player
from engine.level import Level
from engine.ui.menus import MenuInterface
from engine.ui.ui import UI


class Game:
    def __init__(self) -> None:
        pygame.init()

        pygame.display.set_caption("Pacman")

        self.__screen = pygame.display.set_mode(
            (800, 800), pygame.HWSURFACE | pygame.DOUBLEBUF
        )

        self.__clock = pygame.time.Clock()

        self.__current_level = 1

        self.__player: Player = Player(-100, -100)

        self.__menu = MenuInterface(
            {"start": self.start, "quit": self.quit, "resume": self.resume}
        )
        self.__menu.open_main()

        self.__is_paused = False
        self.__is_running = True

        self.__is_debug = True

        self.__level: Level | None = None
        self.__ui = UI()

    def run(self) -> None:
        while self.__is_running:
            self.handle_events()
            self.update()
            self.draw()

            self.__clock.tick(60)

    def handle_events(self) -> None:
        for event in pygame.event.get():
            match event.type:
                case pygame.QUIT:
                    self.quit()
                case pygame.KEYDOWN:
                    if self.__is_debug:
                        self.debug_handle_keydown(event.key)
                    self.__menu.handle_keydown(event.key)
                    self.__player.handle_keydown(event.key)

    def update(self) -> None:
        if self.__level is None:
            return

        self.__menu.update()

        if self.__player.dead() and self.__player.time_since_death() > 3500:
            self.__menu.open_new_record(self.__player.score())
            self.__player = Player(-100, -100)
            return

        if self.__level.is_completed():
            self.__current_level += 1
            self.load_level(self.__current_level + 1)
            return

        self.__level.update()

    def draw(self) -> None:
        self.clear_screen()

        if self.__menu.is_open():
            self.__menu.draw(self.__screen)
        else:
            self.__level.draw(self.__screen)
            self.__ui.display(
                self.__screen,
                pygame.font.SysFont("Arial", self.__menu.get_current_font_size()),
                self.__player.score(),
                self.__current_level,
                self.__player.health(),
            )

        pygame.display.flip()

    def clear_screen(
        self,
    ) -> None:
        self.__screen.fill("black")

    def start(self) -> None:
        self.__menu.close()
        self.__is_paused = False

        self.__player = Player(-100, -100)

        self.__current_level = 1

        self.load_level(self.__current_level)

    def pause(self) -> None:
        self.__is_paused = True
        self.__menu.open_pause()

    def toggle_pause(self) -> None:
        if self.__is_paused:
            self.resume()
        else:
            self.pause()

    def resume(self) -> None:
        self.__is_paused = False
        self.__menu.close()

    def quit(self) -> None:
        pygame.quit()
        sys.exit()

    def load_level(self, level: int) -> None:
        try:
            self.__current_level = level
            self.__level = Level(self.__current_level, self.__player)
        except FileNotFoundError:
            self.__menu.open_game_over()

    def debug_handle_keydown(self, key: int) -> None:
        match key:
            case pygame.K_F1:
                self.start()
            case pygame.K_F2:
                self.load_level(self.__current_level + 1)
            case pygame.K_F3:
                if self.__current_level - 1 < 1:
                    self.load_level(1)
                self.load_level(self.__current_level - 1)
            case pygame.K_F4:
                self.__player.die()
import os
import pygame

from entities.player import Player
from entities.food import Food
from entities.wall import Wall
from entities.ghost import Ghost


class Level(pygame.sprite.Group):
    def __init__(self, number: int, player: Player) -> None:
        super().__init__()

        self.__player = player

        self.__number = number

        self.load()

    @property
    def player(self) -> Player:
        return self.__player

    def load(self) -> None:
        filename = f"assets/levels/{self.__number}.txt"
        if not os.path.exists(filename):
            raise FileNotFoundError(f"Level {self.__number} not found")

        with open(f"assets/levels/{self.__number}.txt", "r") as file:
            data = file.read().splitlines()

        self.empty()

        self.create(data)

    def create(self, data) -> None:
        for y, line in enumerate(data):
            for x, tile in enumerate(line):
                match tile:
                    case "=":
                        self.add(Wall(x, y))
                    case "P":
                        self.__player.respawn(x * 40 + 5, y * 40 + 5)
                    case "*":
                        self.add(Food(x, y, "food"))
                    case "C":
                        self.add(Food(x, y, "cherry"))
                    case "B":
                        self.add(Food(x, y, "blueberry"))
                    case "G":
                        speed = round(self.__number * 0.25 + 2)
                        self.add(Ghost(x, y, speed))

    def draw(self, screen: pygame.Surface) -> None:
        for sprite in self.sprites():
            sprite.draw(screen)

        self.__player.draw(screen)

    def update(self) -> None:
        for sprite in self.sprites():
            sprite.update(self)

        self.__player.update(self)

    def is_completed(self) -> bool:
        return not any(isinstance(entity, Food) for entity in self.sprites())
from engine.game import Game


def main() -> None:
    game = Game()
    game.run()


if __name__ == "__main__":
    main()
